# 读书笔记

- 传统编译语言流程
  1. 分词/词法分析（Tokenizing/Lexing）
  2. 解析/语法分析（Parsing）
  3. 代码生成
- ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。
- **作用域是一套规则，用于确定在何处以及如何查找变量（标识符**）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
- JavaScript 使用的是**词法作用域**
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
- 欺骗词法的两种方式（尽量少用，带来的好处无法抵消性能上的损失）
  1. eval(xxx: string)，在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样
  2. with(xxx: object)，eval**修改**其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空**创建**了一个全新的词法作用域
- 最小特权原则（最小授权或最小暴露原则）：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
- 匿名函数表达式缺点：
  1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难
  2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身
  3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。
- 始终给函数表达式命名是一个最佳实践
- es6 之前块作用域的替代方案：使用 try-catch，因为 catch 会产生块级作用域
- 无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。
- 模块模式需要具备两个必要条件
  1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）
  2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态
- 箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。
- 关于 this 的两种常见误解：
  1. 指向自身
  2. 指向它的词法作用域
- this 的绑定和函数声明的位置没有任何联系，**只取决于函数的调用方式**
- this 的绑定规则：

  1. 默认绑定（独立函数调用），this 指向全局对象（严格模式下，this 为 undefined）
  2. 隐式绑定
  3. 显示绑定，call/apply/bind
  4. new 绑定，实际上并不存在“构造函数”，只有对于函数的“构造调用”

     new 一个函数的基本步骤：

     1. 创建（或者说构造）一个全新的对象。
     2. 这个新对象会被执行 [[原型]] 连接。
     3. 这个新对象会绑定到函数调用的 this。
     4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

  绑定优先级：

  1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar = new foo()
  2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。 var bar = foo.call(obj2)
  3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 var bar = obj1.foo()
  4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象

  **ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this**，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样

- typeof null === 'object'原理：不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”
- 对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置
- in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中（参见第 5 章）。相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链
