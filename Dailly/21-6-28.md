# 记一次简单的业务改造

1. ts 改造
2. 接口请求 fallback
3. 堆上一点点细节
4. useAntTable + 去除不必要的 redux
5. useAntTable 改造（ts 类型、mutate、pagination）
6. CopyTooltip
7. 路由缓存处理
8. Code Spell Checker

## 背景

从 Vue 初转 React 技术栈，搬砖过程中刚好有个通用业务场景练手，顺便记录一下追逐“最佳实践”的过程（虽然很可能一个月后就会变成自己都嫌弃的 🌶 🐔 代码）。

但结果不重要，重要的是优化思路和实践过程。**本篇不会长篇累牍讲所有技术实现细节，只拎出来我认为最关键的部分**，毕竟打工人的时间有限...

## 场景

对于下面这样一个简单的后台管理系统表格展示界面，我们应该早已司空见惯：

![image.png](https://i.loli.net/2021/06/28/cYZQs3trPmpgkOH.png)

以 React + React-router + Redux + TypeScript + Antd 技术栈为前提，在第一时间我们草拟出以下大概的组件划分思路：

![cYZQs3trPmpgkOH.png](https://i.loli.net/2021/06/28/89ik2UxzdOZImJr.png)

## 过程

按照上图的规划，其实 Antd 已经帮我们完成了大部分的工作。我们要做的可能就是“简单的”处理接口请求以及“政治正确”的使用 redux 去组织视图数据，这里我们更近一步使用了官方工具集 @reduxjs/toolkit，听起来不错？但是当我接手旧项目的时候很快就发现了第一个扎眼的问题：TypeScript 类型缺失。对于处女座来说不能忍，于是首先开启的是疯狂的“补齐”之旅...

### TypeScript 改造

#### 1. 接口请求方法

擒贼先擒王，首先找到动态数据的最主要来源——**异步请求**：

```diff
+ import { ActivityList } from 'src/types'
export function getConnectList(params: ConnectListParams) {
- return request.get('/v1/offline-business-connect/list', {
+ return request.get<ActivityList>('/v1/offline-business-connect/list', {
    params: {
      is_close: params.isClose || '',
      page: params.page || 1,
      page_size: params.page_size || 10,
      keyword: params.keyword || '',
    },
  });
}
```

之前的返回类型完全未知，现在传入 ActivityList 泛型，并且用 GetActivityListParams 进行请求参数约束（通过下面的特殊注释方式，可以在 vscode 等现代 IDE 中获取注释提示）。

```typescript
/**
 * 活动列表请求参数
 */
export interface GetActivityListParams {
  isClose?: string | number;
  page?: string | number;
  page_size?: string | number;
  keyword?: string | number;
  type?: string | number;
}

/**
 * 活动列表
 */
export interface ActivityList {
  /* 总数 */
  total_count: number;
  /* 列表 */
  list: ActivityListItem[];
}

/**
 * 活动列表详情
 */
export type ActivityListItem = {
  /** 活动结束时间 */
  activity_end_time: string;
  /** 活动开始时间 */
  activity_start_time: string;
  /** 活动地址 */
  activity_url: string;
  /** 活动名称 */
  area_name: string;
  /** 开发商收集链接 */
  demand_collect_url: string;
  /** 报名需求数目 */
  developer_apply_count: number;
  /** 报名开发商数目 */
  developer_register_count: number;
  /** 是否下架 */
  is_close: 0 | 1;
  /** 报名供应商数目 */
  supplier_register_count: number;
  /** 活动id */
  uid: number;
};
```

直捣黄龙，这样我们在一次基本请求中接口数据的输入端和输出端都有了类型约束的保障，开始好起来了。

~~虽然写完接口定义的样子很靓仔，但是你工具人般倒腾类型时的过程真的好狼狈~~~

这种“脏又累”还容易出错的活儿最好交给工具，当然终极梦想是直接由后台带出，这里感谢组内小伙伴贡献的好东西三枚：

1. [JSON 转 typescript 定义实用工具](https://etctest.cyzl.com/hello_json)，根据 JSON 格式自动生成类型定义，简单粗暴但是现阶段很实用
2. [基于 swagger3 的实用 typescript 工具](https://www.npmjs.com/package/swagger-ts-define)，自动化程度很高，但是强依赖于 swagger3，可以参考源码思路
3. [基于 YApi 的 typescript 和 api request 自动生成工具](https://github.com/fjc0k/yapi-to-typescript)，需要花功夫集成，未来可期

##### 请求小插曲

这里遇到了开发过程中经常能遇到的一个错误写法：

```typescript
// before
export function getActivityList(params: GetActivityListParams) {
  return request.get<ActivityList>('/v1/xxx/list', {
    params: {
      is_close: params.isClose || '',
      page: params.page || 1,
      page_size: params.page_size || 10,
      keyword: params.keyword || '',
      type: params.type || '',
    },
  });
}
```

这里的问题就是 `||`，我们的本意是当左边的值不存在的时候用右边的值进行 fallback，理论上上来说这是良好的习惯，但在这里却是“好心干坏事”，因为当左边的值为 0 时，隐式转换会让我们原本期望传的`is_close`枚举从 0 变成了 ''、`page`从 0 变成 1。在这种情况下我们一定要进行类型判断。

#### 2. redux 相关

让我们先接受“项目就是需要 redux”的设定，然后去解决一些实际存在的有用的问题。

**redux 是我们实际使用数据的根据地，数据的操作最终也会通过 dispatch 来到这里进行异步处理**，因此第二个需要改造 ts 的地方便选在这里。

由于项目里采用`@loadable/component`实现路由的异步加载，因此会导致动态加载的模块对应的 reducer 不存在，解决思路是在运行时将当前模块对应的 reducer 和已有的静态和动态 reducers 进行一次合并然后动态注入（`store.replaceReducer`）。

对应的工具方法 injectReducer，维护了一个 asyncReducers 对象，在路由切换时不断进行对新旧 reducer 进行合并操作：

```typescript
// core
const asyncReducers: LooseObject = {};
export function injectReducer<State>(key: string, reducer: Reducer<State>) {
  asyncReducers[key] = reducer;
  const newRootReducer = combineReducers({
    ...staticReducers,
    ...asyncReducers,
  });
  store.replaceReducer(newRootReducer);
}
// 实际使用
// other.tsx
import { sliceName, sliceReducer } from './slice';
// ...
injectReducer(sliceName, sliceReducer);
// ...
```

这种做法解决了上下文问题，但多了一些切换路由（没有进行缓存）运行时的消耗。

同时带出了第二个问题：**作为静态类型语言 typescript 是没办法做到运行时的类型插拨的**，我们得用“断言”的思路去处理，即**路由到了这个地方，我明确的知道当前的 redux 需要何种类型的数据，并与根数据进行类型合并**。好在`injectReducer`执行注入的时机刚好就是我们有了“明确的知道当前的 redux 需要何种类型的数据”的前提，剩下的事就只有“类型合并”了，核心代码是下面`ApplyListState`联合类型的写法：

```typescript
import { createSlice } from '@reduxjs/toolkit';
// 根数据类型
import { RootState } from 'src/reducers';
// 初始值（state类型出处）
export const initialState = {
  isFetching: true,
  isLoaded: false,
  data: {
    list: [],
    total_count: 0,
    is_allowed_list_export: false,
  } as ApplyList,
};
// 用 `as const` 是为了接下来用作联合类型的 key 值。
export const applyListSliceName = 'applyListSlice' as const;

const applyListSlice = createSlice({
  name: applyListSliceName,
  initialState,
  extraReducers(builder) {
    // 异步请求的reducer处理
    builder
      .addCase(getApplyList.pending, (state) => {
        state.isFetching = true;
        state.isLoaded = true;
      })
      .addCase(getApplyList.fulfilled, (state, action) => {
        state.isFetching = false;
        state.isLoaded = false;
        state.data = action.payload;
      })
      .addCase(getApplyList.rejected, (state) => {
        state.isFetching = false;
        state.isLoaded = false;
      });
  },
  reducers: {},
});

// export reducer
export const applyListReducer = applyListSlice.reducer;

// 类型合并
export type ApplyListState = RootState & {
  [applyListSliceName]: ReturnType<typeof applyListReducer>;
};
```

#### 3. 实际使用相关

举个最容易观察的例子：给 Antd Table 组件的 columns 对象传入实际泛型进行约束

```typescript
import { Table, TableColumnsType } from 'antd';
// 条目类型
import { ApplyListItem } from 'src/api/applyList';
// ...
// 给TableColumnsType传入ApplyListItem
const columns: TableColumnsType<ApplyListItem> = [
  //...
];
// ...
return <Table columns={columns} rowKey={(record) => record.id} />;
```

实际效果： ![image.png](https://i.loli.net/2021/06/02/QyCG9geRfd4mAiO.png)

### 关注点分离

目光回到这幅划分图 ↓ 梳理一下我们现在需要的主体信息：

![cYZQs3trPmpgkOH.png](https://i.loli.net/2021/06/28/89ik2UxzdOZImJr.png)

#### 不变的部分

可以看到中间和底部区域是每个表格展示页都必然有的部分：

中间的 Table 组件，核心的 props 有：

1. 列配置 columns，负责 Table.Columns 的展示
2. 数据列表 dataSource，负责 Table.Rows 的展示
3. 加载状态 loading，负责加载状态的展示

底部的 Pagination 组件，核心的 props 有：

1. 分页索引 pageIndex
2. 单页数据量 pageSize
3. 数据总数 total
4. onChange 回调函数，负责处理当前分页和重新请求

**可以看到以上每项都跟接口数据交互有关，也就是说都需要在 redux 这个根据地上进行相应的维护**

如此简单的页面却要写一大堆无法复用的 redux 样本代码，此时这种模式带来的心智负担不可谓不多：

1. 通过`createSlice`构造 reducer 和 actions
2. 通过`createAsyncThunk`对异步请求进行封装并将这个 thunk 用 extraReducers 进行各种状态流的处理
3. 用`createSelector`将页面实际用到的数据进行缓存处理分发
4. 在实际页面中引入并 inject 对应 reducer
5. 在实际页面中引入 `useDispatch`、`useSelector`和对应的 actions、selects，引用一条变量需要`const state1 = useSelector(selectState1())`，调用一个 action 需要`dispatch(action1())`
6. 为了方便处理很可能还需要用各种不必要的变量和方法去接收 redux 导出的各种“概念”

此时我们的界面形式是这样的（绿色为数据变量，紫色为 action，黄色为实际页面，中间虚线留个小小悬念）：

![image.png](https://i.loli.net/2021/06/29/dpInDSTmQyzjXvG.png)

可以看到绿色和紫色部分很明显是**相同的不同组成部分**。翻译成人话再说一遍：**A 和 B 的具体数据值和操作方法可能不同，但是他们代码的组织形式是完全一致且完全可以复用的**。

此时 redux 却如同一道屏障把他们相隔，并且实际开发过程中我们的关注点不断的在页面逻辑本身和 redux 对应的 state、actions、selector 中横跳，加一个简单的变量动辄要改动好几个地方。

我愿称之为**关注点在不同文件中横跳**。

#### 变动的部分

下图红色区域就是刚才虚线的部分，其实就是我们对表格的操作区域，比如关键词搜索、选项筛选、新增按钮、导入/导出，每个页面都不一样，有些页面可能压根都没有。

![image.png](https://i.loli.net/2021/06/29/kxvpH7hsGFSDn4o.png)

对于这种灵活性极强的需求我们似乎没有办法了，于是代码里充斥着：

```typescript
// 特别强调！这里的代码还经过了简化！刨除了redux的所有影响！
// 特别强调！这里的代码还经过了简化！刨除了redux的所有影响！
// 特别强调！这里的代码还经过了简化！刨除了redux的所有影响！
const demo: React.FC = () => {
  const [keyword, setKeyword] = useState('');
  const [status, setStatus] = useState('');
  // 做其他一大堆事
  // ...
  const onChangeKeyWord = () => {};
  const onSearch = () => {};
  const onStatusChange = () => {};
  // 做其他一大堆事
  // ...
  return (
    <div>
      <Input
        placeholder="请输入关键词"
        onChange={onChangeKeyword}
        onPressEnter={onSearch}
        value={keyword}
      />
      <label>
        <span>状态</span>
        <Select defaultValue="全部" onChange={onStatusChange} value={status}>
          <Option value="">全部</Option>
          <Option value="1">状态1</Option>
          <Option value="2">状态2</Option>
        </Select>
      </label>
      <Table {...tableProps}></Table>
    </div>
  );
};
```

上例每一个 value 都对应着一个 state (`keyword`、`status`)和一个维护 state 的回调函数(`onChangeKeyword`、`onSearch`、`onStatusChange`)，哪怕你已经严格按照开发规范将他们按顺序排列的稳稳当当，但相同领域的代码逻辑在一个纵向空间里仍然是散落的，实际开发过程中关注点需要不断的上下转换。

以下是针对上面的简版伪代码画的关注点草图，可以看到改动一个小小的 keyword 就够我们在代码里上下来回切换好几遍。

![image.png](https://i.loli.net/2021/06/29/i3V56l4yhNYMWEQ.png)

更别提后续映射到 redux 的链路，简直是“又臭又长”，redux 加持后上述例子的切换次数需要**乘以对应 redux 文件的数目**，在这里也是没有复用的。

我愿称之为**关注点的上下横跳**

**最最可气的是，redux 的数据中心化管理在这个应用中完完全全没有运用，也就是说我们之前完全是用 redux 规定的路数照本宣科的机械式式完成任务，每个路由的数据却并不是实时共享共用的。**

妥妥的杀鸡用牛刀，**并且还用了杀牛的力**。
