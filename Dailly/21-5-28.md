# 读书笔记

- JavaScript 中的 thunk（形实转换程序） 是指一个用于调用另外一个函数的函数，没有任何参数。
- Web Work 分为通过 URL 创建的专用 Worder（Dedicated Worker）和通过 Blob URL 创建的在线 Worker（Inline Worker）
- 通常由主页面应用程序创建 Worker，但若是需要的话，Worker 也可以实例化它自己的子 Worker，称为 subworker。有时候，把这样的细节委托给一个“主”Worker，由它来创建其他 Worker 处理部分任务
- 如果浏览器中有两个或多个页面（或同一页上的多个 tab ！）试图从同一个文件 URL 创建 Worker，那么最终得到的实际上是完全独立的 Worker
- 在 Worker 内部是无法访问主程序的任何资源的。这意味着你不能访问它的任何全局变量，也不能访问页面的 DOM 或者其他资源。记住，这是一个完全独立的线程。但是，你可以执行网络操作（Ajax、WebSockets）以及设定定时器。还有，Worker 可以访问几个重要的全局变量和功能的本地复本，包括 navigator、location、JSON 和 applicationCache。你还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本： // 在 Worker 内部 importScripts( "foo.js", "bar.js" ); 这些脚本加载是同步的。也就是说，importScripts(..) 调用会阻塞余下 Worker 的执行，直到文件加载和执行完成
- 可通过 new SharedWorker 创建共享的中心 Worker。与这个共享 Worker 通信需要使用.port（w1.port.postMessge(xxx)），此外端口连接需要初始化 （w1.port.start()）。同时在 Worker 内部还需要额外处理一个 connect 事件：
  ```javascript
  // 在共享Worker内部
  addEventListener( "connect", function(evt){
  // 这个连接分配的端口
  var port = evt.ports[0];
  port.addEventListener( "message", function(evt){
  // ..
  port.postMessage( .. );
  // ..
  } );
  // 初始化端口连接
  port.start();
  } );
  ```
- V8 古早优化细节两则：
  1. 不要从一个函数到另外一个函数传递 arguments 变量，因为这样的泄漏会降低函数实现速度
  2. 把 try..catch 分离到单独的函数里。浏览器对任何有 try..catch 的函数实行优化都有一些困难，所以把这部分移到独立的函数中意味着你控制了反优化的害处，并让其包含性能测试与调优的代码可以优化。
- 尾调用优化(Tail Call Optimization,TCO)：一个出现在另一个函数“结尾”处的函数调用。这个调用结束后就没有其余事情要做了（除了可能要返回结果值）。尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变得实际。TCO 允许一个函数在结尾处调用另外一个函数来执行，不需要任何额外资源。这意味着，对递归算法来说，引擎不再需要限制栈深度。
- 函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用记录上方，还会形成一个 B 的调用记录。等到 B 运行结束，将结果返回到 A，B 的调用记录才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用记录栈，以此类推。所有的调用记录，就形成一个"调用栈"（call stack）。
- 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。
