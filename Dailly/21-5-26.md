# 读书笔记

- Promise 的局限性
  1. 顺序错误处理：Promise 的设计局限性（具体来说，就是它们链接的方式）造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被无意中默默忽略掉。并且由于一个 Promise 链仅仅是连接到一起的成员 Promise，没有把整个链标识为一个个体的实体，这意味着没有外部方法可以用于观察可能发生的错误。任何地方的任何错误都会在链中一直传播下去，直到被查看（通过在某个步骤注册拒绝处理函数）。
  2. 单一性：Promise 只能有一个完成值或一个拒绝理由，在复杂的场景中，可能是一种局限
  3. 单决议：Promise 只能被决议一次（完成或拒绝）
  4. 惯性：用 Promise 的范式重构基于回调函数的旧代码代价比较大
  5. 无法取消：一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程
  6. 性能：把基本的基于回调的异步任务链与 Promise 链中需要移动的部分数量进行比较。很显然， Promise 进行的动作要多一些，这自然意味着它也会稍慢一些（需要辩证的看待）。这与 Promise 带来的好处来说微不足道，如果说 Promise 确实有一个真正的性能局限的话，那就是它们没有真正提供可信任性保护支持的列表以供选择（你总是得到全部）
- Generator 生成器是一种用顺序、看似同步的异步流程控制表达风格，也可以理解为一个状态机，封装了多个内部状态
- 在 Generator 中，**消息是双向传递的**，yield...作为一个表达式可以发出消息响应 next(..) 调用，next(..) 也可以向暂停的 yield 表达式发送值
- yield 表达式本身是没有返回值的，或者说总是返回 undefined，next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为
- 只有暂停的 yield 才能接受这样一个通过 next(..) 传递的值，而在生成器的起始处我们调用第一个 next() 时，还没有暂停的 yield 来接受这样一个值。规范和所有兼容浏览器都会默默丢弃传递给第一个 next() 的任何东西。传值过去仍然不是一个好思路，因为你创建了沉默的无效代码，这会让人迷惑。因此，启动生成器时一定要用不带参数的 next()

# 前端双周会

- next 注入 cookie 导致的白屏问题
- TIM IM SDK 封装细节和突出问题分享
  1. 数据（reducer）和视图（UI）封装
  2. ts 类型补足
  3. 兼容性问题

# 问题记录

- react jsx 中绑定的变量（props/state）与 vue 中的“双向绑定”概念是不同的，也并非 proxy 或者 watcher，要完全摒弃这种“直觉”。如下面的`count`变量，在 react 中，它被称作 capture value（数据快照），每次 render 行为都是一个由 react 提供的不变的（immutable）独立的常量值，在整个渲染过程中始终不变。

  ```javascript
  function Counter() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>Click me</button>
      </div>
    );
  }
  ```

- react 只会在浏览器绘制后运行 effects。这使得你的应用更流畅因为大多数 effects 并不会阻塞屏幕的更新。effect 的清除同样被延迟了。上一次的 effect 会在重新渲染后被清除。而在下一次渲染中之所以还能获取上一次的上下文主要得益于闭包机制。标准流程：
  1. React 渲染当前状态值`$2`下的 UI
  2. 浏览器绘制`$2`的 UI
  3. React 清除之前状态值`$1`的 effect（如果 effect 返回了函数的话）
  4. React 运行`$2`的 effect
- `useEffect`的另一种理解：用 react 的方式，依照当前渲染行为中的 props 和 state 用第一个参数（回调函数）去同步 react tree 之外的东西（副作用）。用第二个参数（依赖数组）显示声明变更依赖项，react 根据这份声明确保性能
- 当在`useEffect`中更新一个状态并且这个状态同时依赖于另一个状态值的时候，可以使用`useReducer`来替换，reducer 的模式可以把发生了什么和状态如何响应的行为进行解耦：

  ```javascript
  function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);
    const { count, step } = state;

    useEffect(() => {
      const id = setInterval(() => {
        dispatch({ type: 'tick' });
      }, 1000);
      return () => clearInterval(id);
    }, [dispatch]); //dispatch不会改变

    return (
      <>
        <h1>{count}</h1>
        <input
          value={step}
          onChange={(e) => {
            dispatch({
              type: 'step',
              step: Number(e.target.value),
            });
          }}
        />
      </>
    );
  }

  const initialState = {
    count: 0,
    step: 1,
  };

  function reducer(state, action) {
    // 脏活累活交给reducer
    const { count, step } = state;
    if (action.type === 'tick') {
      return { count: count + step, step };
    } else if (action.type === 'step') {
      return { count, step: action.step };
    } else {
      throw new Error();
    }
  }
  ```

- effect 不应该对它的依赖“说谎”（开启 exhaustive-deps lint 规则），哪怕它的依赖项是一个函数。当然，在组件内部定义的函数跟变量一样每次渲染都会发生改变，因此为了 effect 因为依赖度函数频繁调用，有以下两个解决办法：
  1. 如果是一个纯函数，没有使用组件内的任何值，应该把它提升到组件外部，这样可以在 effect 的依赖项里去掉该函数
  2. 非纯函数，通过`useCallback`包装（或者`useMemo`），让 react 在每次渲染后提供对该函数的依赖检查决定是否变化，effect 依赖中添加这个包装后返回的函数
- 在 class 组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI 渲染是被 props 和 state 驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。而在`useEffect`的思维模型中，默认都是同步的。副作用变成了 React 数据流的一部分。对于每一个`useEffect`调用，一旦你处理正确，你的组件能够更好地处理边缘情况
- 一次在组件中获取数据映射的简单最佳实践：

  ```javascript
  // 提炼处理的hooks
  const useDataApi = (initialUrl, initialData) => {
    const [url, setUrl] = useState(initialUrl);

    // 利用useReducer解耦数据和行为
    const [state, dispatch] = useReducer(dataFetchReducer, {
      isLoading: false,
      isError: false,
      data: initialData,
    });

    useEffect(() => {
      // 防止竞态产生的错误异步处理标志
      let didCancel = false;

      const fetchData = async () => {
        dispatch({ type: 'FETCH_INIT' });

        try {
          const result = await axios(url);
          // 添加判断
          if (!didCancel) {
            dispatch({ type: 'FETCH_SUCCESS', payload: result.data });
          }
        } catch (error) {
          // 添加判断
          if (!didCancel) {
            dispatch({ type: 'FETCH_FAILURE' });
          }
        }
      };

      fetchData();

      // 在清除函数中设置为true，防止此时不可预估时间的异步结果调用错误的数据处理action
      return () => {
        didCancel = true;
      };
    }, [url]);

    return [state, setUrl];
  };
  ```
