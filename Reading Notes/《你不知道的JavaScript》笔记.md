# 读书笔记


- 传统编译语言流程
  1. 分词/词法分析（Tokenizing/Lexing）
  2. 解析/语法分析（Parsing）
  3. 代码生成
- ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。
- **作用域是一套规则，用于确定在何处以及如何查找变量（标识符**）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
- JavaScript 使用的是**词法作用域**
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
- 欺骗词法的两种方式（尽量少用，带来的好处无法抵消性能上的损失）
  1. eval(xxx: string)，在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样
  2. with(xxx: object)，eval**修改**其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空**创建**了一个全新的词法作用域
- 最小特权原则（最小授权或最小暴露原则）：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
- 匿名函数表达式缺点：
  1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难
  2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身
  3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。
- 始终给函数表达式命名是一个最佳实践
- es6 之前块作用域的替代方案：使用 try-catch，因为 catch 会产生块级作用域
- 无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。
- 模块模式需要具备两个必要条件
  1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）
  2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态
- 箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。
- 关于 this 的两种常见误解：
  1. 指向自身
  2. 指向它的词法作用域
- this 的绑定和函数声明的位置没有任何联系，**只取决于函数的调用方式**
- this 的绑定规则：

  1. 默认绑定（独立函数调用），this 指向全局对象（严格模式下，this 为 undefined）
  2. 隐式绑定
  3. 显示绑定，call/apply/bind
  4. new 绑定，实际上并不存在“构造函数”，只有对于函数的“构造调用”

     new 一个函数的基本步骤：

     1. 创建（或者说构造）一个全新的对象。
     2. 这个新对象会被执行 [[原型]] 连接。
     3. 这个新对象会绑定到函数调用的 this。
     4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

  绑定优先级：

  1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar = new foo()
  2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。 var bar = foo.call(obj2)
  3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 var bar = obj1.foo()
  4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象

  **ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this**，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样

- typeof null === 'object'原理：不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”
- 对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置
- in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中（参见第 5 章）。相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链



- 所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看
- 由 于 基 本 类 型 值 没 有 .length 和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装（box 或者 wrap）一个封装对象：

  ```jsx
  var a = 'abc';
  a.length; // 3
  a.toUpperCase(); // "ABC"
  ```

- 如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数：

  ```jsx
  var a = new String('abc');
  var b = new Number(42);
  var c = new Boolean(true);
  a.valueOf(); // "abc"
  b.valueOf(); // 42
  c.valueOf(); // true
  ```

- `new Array(5)`出来的只是一个空数组（稀疏数组），只不过 length 被设置成了 5，这样奇特的数据结构会导致一些怪异的行为，不同浏览器的开发控制台显示的结果也不尽相同。而这一切都归咎于已被废止的旧特性（类似 arguments 这样的类数组），`Array.apply( null, { length: 5 } )`比上面的靠谱多了
- 使用常量形式（如 `/^a*b+/g`）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。
- 创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分 JavaScript 引擎通过只读属性 .stack 来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。
- Symbol 并非对象，而是一种简单标量基本类型


- 所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看
- 由 于 基 本 类 型 值 没 有 .length 和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装（box 或者 wrap）一个封装对象：

  ```jsx
  var a = 'abc';
  a.length; // 3
  a.toUpperCase(); // "ABC"
  ```

- 如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数：

  ```jsx
  var a = new String('abc');
  var b = new Number(42);
  var c = new Boolean(true);
  a.valueOf(); // "abc"
  b.valueOf(); // 42
  c.valueOf(); // true
  ```

- `new Array(5)`出来的只是一个空数组（稀疏数组），只不过 length 被设置成了 5，这样奇特的数据结构会导致一些怪异的行为，不同浏览器的开发控制台显示的结果也不尽相同。而这一切都归咎于已被废止的旧特性（类似 arguments 这样的类数组），`Array.apply( null, { length: 5 } )`比上面的靠谱多了
- 使用常量形式（如 `/^a*b+/g`）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。
- 创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分 JavaScript 引擎通过只读属性 .stack 来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。
- Symbol 并非对象，而是一种简单标量基本类型



1. JavaScript 中的强制类型转换总是返回标量基本类型值，如字符串、数字和布尔值，不会返回对象和函数。而“封装”，就是为标量基本类型值封装一个相应类型的对象，但这并非严格意义上的强制类型转换。
2. 类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在强制类型转换动态类型语言的运行时（runtime）
3. 可以运用 JSON.stringify 会自动判别对象的循环引用的特性，直接拿来进行相关的操作
4. JSON.stringify(source: any, replacer?: string[] | (k, v) ⇒ any)
5. JavaScirpt 中 Toboolean 的假值，其他值可以理解为真：
   - undefined
   - null
   - false
   - +0、-0、NaN
   - ""



- == 允许在相等比较中进行强制类型转换，而 === 不允许
- 无论什么情况下都不要使用 == true 和 == false
- "0" == null; // false "0" == undefined; // false "0" == false; // true "0" == NaN; // false "0" == 0; // true "0" == ""; // false false == null; // false false == undefined; // false false == NaN; // false false == 0; // true false == ""; // true false == []; // true false == {}; // false "" == null; // false "" == undefined; // false "" == NaN; // false "" == 0; // true "" == []; // true "" == {}; // false 0 == null; // false 0 == undefined; // false 0 == NaN; // false 0 == []; // true 0 == {}; // false

      [] == ![] // true

      0 == "\n"; // true

- JSON 的确是 JavaScript 语法的一个子集，但是 JSON 本身并不是合法的 JavaScript 语法。
- if 和 else 只包含单条语句的时候可以省略代码块的 { }，因此 JavaScript 没有 else if，我们使用到的 else if 实际上是省略了{}之后的用法。这样能省掉一层代码缩进，所以很受青睐。但这只是我们自己发明的用法，切勿想当然地认为这些都属于 JavaScript 语法的范畴
- JavaScript 中的 && 和 || 运算符返回它们其中一个操作数的值，而非 true 或 false
- 语句和表达式在英语中都能找到类比——语句就像英语中的句子，而表达式就像短语。表达式可以是简单独立的，否则可能会产生副作用
- JavaScript 中有很多错误类型，分为两大类：早期错误（编译时错误，无法被捕获）和运行时错误（可以通过 try..catch 来捕获）。所有语法错误都是早期错误，程序有语法错误则无法运行。



- JavaScript 程序总是至少分为两个块：第一块现在运行；下一块将来运行，以响应某个事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累积的修改之上进行的
- 在某些条件下，某些浏览器的 console.log(..) 并不会把传入的内容立即输出。出现这种情况的主要原因是，在许多程序（不只是 JavaScript）中，I/O 是非常低速的阻塞部分。所以，（从页面 /UI 的角度来说）浏览器在后台异步处理控制台 I/O 能够提高性能，这时用户甚至可能根本意识不到其发生。如果遇到这种少见的情况， - 最好的选择是在 JavaScript 调试器中使用断点，而不要依赖控制台输出。 - 次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过 JSON.stringify(..)
- JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”（JavaScript 代码执行）调度**总是由包含它的环境进行**
- 术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。记住，异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。
- 单线程事件循环是并发的一种形式
- 严格说来，setTimeout(..0) 并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。举例来说，两个连续的 setTimeout(..0) 调用不能保证会严格按照调用顺序处理，所以各种情况都有可能出现，比如定时器漂移，在这种情况下，这些事件的顺序就不可预测。在 Node.js 中，类似的方法是 process.nextTick(..)。尽管它们使用方便（通常性能也更高），但并没有（至少到目前为止）直接的方法可以适应所有环境来确保异步事件的顺序
- 回调函数包裹或者说封装了程序的延续（continuation）
- 编写异步事件代码，特别是当回调是唯一的实现手段时，困难之处就在于这种思考 / 计划的意识流对我们中的绝大多数来说是不自然的。我们的思考方式是一步一步的，但是从同步转换到异步之后，可用的工具（回调）却不是按照一步一步的方式来表达的。这就是为什么精确编写和追踪使用回调的异步 JavaScript 代码如此之难：因为**这并不是我们大脑进行计划的运作方式**。
- **回调最大的问题是控制反转，它会导致信任链的完全断裂**
- Promise 把现在和将来的所有操作都进行了**归一化处理**
- 从外部看，由于 Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝，所以 Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成（组合），而不用关心时序或底层的结果。另外，一旦 Promise 决议，它就永远保持在这个状态。此时它就成为了不变值（immutable value），可以根据需求多次查看。
- Promise 从另一个角度理解：一种在异步任务中作为两个或更多步骤的流程控制机制，时序上的 thisthen-that。
- 鸭子类型（duck typing）：如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是只鸭子



- Promise 的局限性
  1. 顺序错误处理：Promise 的设计局限性（具体来说，就是它们链接的方式）造成了一个让人很容易中招的陷阱，即 Promise 链中的错误很容易被无意中默默忽略掉。并且由于一个 Promise 链仅仅是连接到一起的成员 Promise，没有把整个链标识为一个个体的实体，这意味着没有外部方法可以用于观察可能发生的错误。任何地方的任何错误都会在链中一直传播下去，直到被查看（通过在某个步骤注册拒绝处理函数）。
  2. 单一性：Promise 只能有一个完成值或一个拒绝理由，在复杂的场景中，可能是一种局限
  3. 单决议：Promise 只能被决议一次（完成或拒绝）
  4. 惯性：用 Promise 的范式重构基于回调函数的旧代码代价比较大
  5. 无法取消：一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程
  6. 性能：把基本的基于回调的异步任务链与 Promise 链中需要移动的部分数量进行比较。很显然， Promise 进行的动作要多一些，这自然意味着它也会稍慢一些（需要辩证的看待）。这与 Promise 带来的好处来说微不足道，如果说 Promise 确实有一个真正的性能局限的话，那就是它们没有真正提供可信任性保护支持的列表以供选择（你总是得到全部）
- Generator 生成器是一种用顺序、看似同步的异步流程控制表达风格，也可以理解为一个状态机，封装了多个内部状态
- 在 Generator 中，**消息是双向传递的**，yield...作为一个表达式可以发出消息响应 next(..) 调用，next(..) 也可以向暂停的 yield 表达式发送值
- yield 表达式本身是没有返回值的，或者说总是返回 undefined，next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为
- 只有暂停的 yield 才能接受这样一个通过 next(..) 传递的值，而在生成器的起始处我们调用第一个 next() 时，还没有暂停的 yield 来接受这样一个值。规范和所有兼容浏览器都会默默丢弃传递给第一个 next() 的任何东西。传值过去仍然不是一个好思路，因为你创建了沉默的无效代码，这会让人迷惑。因此，启动生成器时一定要用不带参数的 next()



- JavaScript 中的 thunk（形实转换程序） 是指一个用于调用另外一个函数的函数，没有任何参数。
- Web Work 分为通过 URL 创建的专用 Worder（Dedicated Worker）和通过 Blob URL 创建的在线 Worker（Inline Worker）
- 通常由主页面应用程序创建 Worker，但若是需要的话，Worker 也可以实例化它自己的子 Worker，称为 subworker。有时候，把这样的细节委托给一个“主”Worker，由它来创建其他 Worker 处理部分任务
- 如果浏览器中有两个或多个页面（或同一页上的多个 tab ！）试图从同一个文件 URL 创建 Worker，那么最终得到的实际上是完全独立的 Worker
- 在 Worker 内部是无法访问主程序的任何资源的。这意味着你不能访问它的任何全局变量，也不能访问页面的 DOM 或者其他资源。记住，这是一个完全独立的线程。但是，你可以执行网络操作（Ajax、WebSockets）以及设定定时器。还有，Worker 可以访问几个重要的全局变量和功能的本地复本，包括 navigator、location、JSON 和 applicationCache。你还可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本： // 在 Worker 内部 importScripts( "foo.js", "bar.js" ); 这些脚本加载是同步的。也就是说，importScripts(..) 调用会阻塞余下 Worker 的执行，直到文件加载和执行完成
- 可通过 new SharedWorker 创建共享的中心 Worker。与这个共享 Worker 通信需要使用.port（w1.port.postMessge(xxx)），此外端口连接需要初始化 （w1.port.start()）。同时在 Worker 内部还需要额外处理一个 connect 事件：
  ```javascript
  // 在共享Worker内部
  addEventListener( "connect", function(evt){
  // 这个连接分配的端口
  var port = evt.ports[0];
  port.addEventListener( "message", function(evt){
  // ..
  port.postMessage( .. );
  // ..
  } );
  // 初始化端口连接
  port.start();
  } );
  ```
- V8 古早优化细节两则：
  1. 不要从一个函数到另外一个函数传递 arguments 变量，因为这样的泄漏会降低函数实现速度
  2. 把 try..catch 分离到单独的函数里。浏览器对任何有 try..catch 的函数实行优化都有一些困难，所以把这部分移到独立的函数中意味着你控制了反优化的害处，并让其包含性能测试与调优的代码可以优化。
- 尾调用优化(Tail Call Optimization,TCO)：一个出现在另一个函数“结尾”处的函数调用。这个调用结束后就没有其余事情要做了（除了可能要返回结果值）。尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变得实际。TCO 允许一个函数在结尾处调用另外一个函数来执行，不需要任何额外资源。这意味着，对递归算法来说，引擎不再需要限制栈深度。
- 函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数 A 的内部调用函数 B，那么在 A 的调用记录上方，还会形成一个 B 的调用记录。等到 B 运行结束，将结果返回到 A，B 的调用记录才会消失。如果函数 B 内部还调用函数 C，那就还有一个 C 的调用记录栈，以此类推。所有的调用记录，就形成一个"调用栈"（call stack）。
- 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。
