---
slug: 21-07-19
---

# 21-07-19[react 图片懒加载组件]

## 背景

项目里经常需要用到 `<image />` 标签，有点小理想的我们一般都会有统一管理的需求，比如错误处理/加载占位/懒加载等等。

在 vue 中一般用指令（比如 `v-lazy`）或者全局注册插件的方式完成这类需求；在 react 中则可以通过封装一个 `Image` 高阶组件的形式去实现（其它很多好的解决方案待学习）。现有项目里就采用了这种方案，但是实现的有点简陋而且还有点小问题，**因此本文主要描述如何兼顾旧有功能的同时进行代码重构和功能增强**。

## 谋定后动

其实无论组件多么复杂，只需一开始就抓住最最重要的两个的部分，即**组件的输入和输出**，就成功了一半。

而输入和输出又由组件的定位所决定，因为做的是一个针对 `<image />` 标签的简单功能增强高阶组件，可以想象这里的代码全程都应该围绕 image 这个 DOM 标签进行服务，因此无关的逻辑不要堆砌于此。

### 输出

这个组件的功能定位很明确，所以首先谈的是输出。我们需要的是一个**增强型 image **，那么组件尾部大可以简单明快的 return 一个 `<img {...usefulProps}/>`，可以看成一个“带副作用的纯函数”~

### 输入

其实原先 Image 组件的输入已经足够丰富， PropsType 如下：

```typescript
interface ImgProp {
  src: string; // 自定义图片地址
  defaultSrc?: string; // 默认图片地址
  alt?: string; // 描述
  style?: React.CSSProperties; // 自定义样式
}
```

根据这些入参推测可以完成的功能有：

1. 图片加载占位
2. 错误处理
3. 样式透传
4. alt 指定替换文本
5. 懒加载

旧组件做的只有 2、3、4。第 1 点的实现思路很简单，这里结合懒加载的实现一起讲。而为了精细化配置第 5 点懒加载，需要加上一个 lazy 配置项，最终入参类型如下：

```typescript
interface ImgProp {
  src: string; // 自定义图片地址
  defaultSrc?: string; // 默认图片地址
  alt?: string; // 描述
  style?: React.CSSProperties; // 自定义样式
  // highlight-next-line
+ lazy?: boolean; // 是否开启懒加载，默认为true
}
```

## 方案选择

### 传统方案

传统懒加载的实现思路是通过事件监听滚动距离实时判断图片元素的高度，再结合视窗高度等信息人为的控制替换图片 src 地址，为了性能优化可能会做个函数节流啥的。这种方式兼容性不错，但性能和啰嗦的判断着实是个问题，现在一般作为 fallback 的方式存在（这边的 fallback 方案其实也不需要了，后文会讲）。

### 激进方案

Chrome 自从 77 版本后 image 和 iframe 原生支持懒加载特性，直接在标签里使用 `loading="lazy"` 即可开启。但这种方式太吃浏览器，基本是个空中楼阁，可以看到下图的惨状，但不妨碍我们了解下：

![image.png](https://i.loli.net/2021/07/20/q4vdiCONy3EWhTf.png)

`loading` 属性有以下支持的值：

1. `lazy`：图片或框架懒加载，也就是元素资源快要被看到的时候加载
2. `eager`： 图片或框架无视一切进行加载
3. `auto`：默认值。图片或框架基于浏览器自己的策略进行加载

根据张鑫旭的这篇文章 [浏览器 IMG 图片原生懒加载 loading=”lazy”实践指南 ](https://www.zhangxinxu.com/wordpress/2019/09/native-img-loading-lazy/)总结这个原生方案的如下几个行为特性：

1. Lazy loading 加载数量与屏幕高度有关，高度越小加载数量越少，但并不是线性关系。
2. Lazy loading 加载数量与网速有关，网速越慢，加载数量越多，但并不是线性关系。
3. Lazy loading 加载没有缓冲，滚动即会触发新的图片资源加载
4. Lazy loading 加载在窗口 resize 尺寸变化时候也会触发，例如屏幕高度从小变大的时候。
5. Lazy loading 加载也有可能会先加载后面的图片资源，例如页面加载时滚动高度很高的时候。

与 JavaScript 有关的几个行为特征：

1. 判断浏览器是否支持原生 loading，最好使用 `'loading' in new Image()` 判断。
2. 获取 loading 属性值可以直接 img.loading；
3. 原生 loading 不可写，例如 HTMLImageElement.prototype.loading 会报错 Illegal invocation。
4. Polyfill 就是场梦，只能等浏览器支持。

### 当前的最佳方案

早在 16 年的 Chrome 51+ 版本浏览器就已经支持了 [IntersectionObserver（交叉观察器）](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)这么一个 API，可以自动异步观察目标元素与指定元素的交叉状态（也就是传统方案中我们费尽心机做的加载时机判断浏览器帮你优雅的搞定啦），那可太棒了！

眉头微微一皱，发现事情并不简单，直觉告诉你：一般这种好东西兼容性肯定不行啦：

![image.png](https://i.loli.net/2021/07/20/YgOsKShtdTFxDvC.png)

果然，支持率虽然有 94.58% 还挺高的，但不支持 IE11 似乎就与我们彻底 886 了？

此时 w3c 爸爸官方出品的 polyfill [intersection-observer](https://www.npmjs.com/package/intersection-observer) 请求出战！可以看到 npm 周下载量高达 75w，兼容度也直接来到 ie7+，一个字：稳！

![image.png](https://i.loli.net/2021/07/20/BDEQ9XJF4Rrq6jv.png)

使用也很简单，在项目的入口文件直接 `import 'intersection-observer'` ，后面就可以正常使用 IntersectionObserver API。

## 懒加载实现

简单的拆分几个关键步骤：

1. lazy 配置决定是否开启懒加载
2. 加载前和加载中都应有可配置的占位图片
3. 合适的时机加载该图片（重点）
4. 错误处理

### 1&2. lazy 配置和占位图片

精简逻辑如下：

```typescript
// 默认占位图片资源
import defaultLogo from 'xxx/default-logo.png';

interface ImgProp {
  src: string; // 自定义图片地址
  defaultSrc?: string; // 默认图片地址
  alt?: string; // 描述
  style?: React.CSSProperties; // 自定义样式
  // highlight-next-line
  lazy?: boolean; // 是否开启懒加载，默认为true
}
const Image: React.FC<ImgProp> = ({
  src,
  defaultSrc,
  alt,
  style,
  // highlight-next-line
  lazy = true,
}) => {
  // 实际的默认占位图片地址
  const realDefaultSrc = defaultSrc || defaultLogo;
  // 实际的真实图片地址
  const realSrc = src || realDefaultSrc;
  // img要用到的src url
  const [srcUrl, setSrcUrl] = useState<string | undefined>(
    // 初始值，如果开启懒加载则是占位图，否则直接加载真实地址
    // highlight-next-line
    lazy ? realDefaultSrc : realSrc
  );
  // ...other code
  return (
    <img
      // highlight-next-line
      data-src={lazy ? realSrc : null}
      src={srcUrl}
      // ...other props
    />
  );
};
```

### 3. 合适时机加载图片

主要思路：合适时机由 IntersectionObserver 提供，结合它提供的 API 和自定义 data-src 属性进行图片加载。

首先需要定义一个全局单例的 rootImageIntersectionObserver 管理实例：

```typescript title="Image/index.tsx"
let rootImageIntersectionObserver: IntersectionObserver | null = null;
// 暴露一个init函数，在根组件的合适时机进行挂载
export const init = () => {
  if (rootImageIntersectionObserver) return rootImageIntersectionObserver;
  rootImageIntersectionObserver = new IntersectionObserver((entries) => {
    // ...todo
  });
  return rootImageIntersectionObserver;
};
// 暴露一个destroy函数，在合适的实际进行销毁
export const destroy = () => {
  // 根组件销毁时记得断开监听
  rootImageIntersectionObserver?.disconnect();
  rootImageIntersectionObserver = null;
};
```

根组件中进行初始化：

```typescript title="App.tsx"
import * as Image from 'src/components/Image';
// ...
// 初始化Image
useEffect(() => {
  Image.init();
  return () => {
    Image.destroy();
  };
}, []);
// ...
```

`Image` 组件内部订阅交叉观察器：

```typescript title="Image/index.tsx"
const Image: React.FC<ImgProp> = ({
  // ...
  lazy = true,
}) => {
  // ...
  // 拿到img元素ref
  const $img = useRef<HTMLImageElement>(null);
  // ...
  useEffect(() => {
    // 如果实例存在且配置了lazy
    if ($img.current && lazy) {
      // 全局交叉观察期添加对该img的订阅
      rootImageObserver?.observe($img.current);
      // 组件销毁时取消订阅，确保性能
      return () => {
        // eslint-disable-next-line react-hooks/exhaustive-deps
        rootImageObserver?.unobserve($img.current as any);
      };
    }
  }, [$img, lazy]);
  return (
    <img
      ref={$img}
      className={styles.lazyImage}
      data-src={lazy ? realSrc : null}
      // ...
    />
  );
};
```

监听的具体回调实现（这里不建议添加节流回调，快速滚动的情况很容易丢失 img 加载，造成一个个的空占位图）：

```typescript title="Image/index.tsx"
// ...
export const init = () => {
  // ...
  rootImageIntersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((item) => {
      // 一行代码即可判断img元素是否在视野范围内冒头，tql
      // highlight-start
      if (item.isIntersecting) {
        // item.target即当前冒头的img元素
        const $img = item.target as HTMLImageElement;
        // 此时根据data-src替换图片正确的src
        $img.src = $img.dataset?.src ?? defaultLogo;
        $img.classList.remove(styles.lazyImage);
        // 完成上述操作即可停止订阅该图片元素，确保性能
        rootImageIntersectionObserver?.unobserve($img);
      }
      // highlight-end
    });
  });
  // ...
};
// ...
```

### 4. 错误处理

逻辑很简单，出错了就回退到占位图片，不需要做其它操作：

```typescript title="Image/index.tsx"
const Image: React.FC<ImgProp> = ({
  src,
  defaultSrc,
  // ...
}) => {
  // 实际的默认占位图片地址
  const realDefaultSrc = defaultSrc || defaultLogo;
  // 实际的真实图片地址
  const realSrc = src || realDefaultSrc;
  const [srcUrl, setSrcUrl] = useState<string | undefined>(
    lazy ? realDefaultSrc : realSrc
  );
  // ...
  // 错误处理回调
  const handleImageError = () => {
    setSrcUrl(realDefaultSrc);
  };
  // ...
  return (
    <img
      // ...
      src={srcUrl}
      onError={handleImageError}
      // ...
    />
  );
};
```

### 其它可以做的事

1. IntersectionObserver.root/IntersectionObserver.rootMargin/IntersectionObserver.thresholds 等的精细配置化
2. delay 延迟时间配置
3. 不依赖官方 polyfill 包，自己写 fallback，这样可以独立发包使用
4. ...

## 完整代码

```typescript
import React, { useState, useEffect, useRef } from 'react';
import defaultLogo from 'src/assets/images/common/defaultlogo.png';
import styles from './index.module.less';

interface ImgProp {
  src: string; // 自定义图片地址
  defaultSrc?: string; // 默认图片地址
  alt?: string; // 描述
  style?: React.CSSProperties; // 自定义样式
  lazy?: boolean; // 是否开启懒加载，默认为true
}

let rootImageIntersectionObserver: IntersectionObserver | null = null;

export const init = () => {
  if (rootImageIntersectionObserver) return rootImageIntersectionObserver;
  // IntersectionObserver配置
  rootImageIntersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((item) => {
      // 一行代码即可判断img元素是否在视野范围内冒头，tql
      if (item.isIntersecting) {
        // item.target即当前冒头的img元素
        const $img = item.target as HTMLImageElement;
        // 此时根据data-src替换图片正确的src
        $img.src = $img.dataset?.src ?? defaultLogo;
        $img.classList.remove(styles.lazyImage);
        // 完成上述操作即可停止订阅该图片元素，确保性能
        rootImageIntersectionObserver?.unobserve($img);
      }
    });
  });
  return rootImageIntersectionObserver;
};

export const destroy = () => {
  // 根组件销毁时记得断开监听
  rootImageIntersectionObserver?.disconnect();
  rootImageIntersectionObserver = null;
};

/**
 * @description 图片控件，新增支持懒加载
 * @param {ImgProp} 图片属性配置
 */
const Image: React.FC<ImgProp> = ({
  src,
  defaultSrc,
  alt,
  style,
  lazy = true,
}) => {
  const realDefaultSrc = defaultSrc || defaultLogo;
  const realSrc = src || realDefaultSrc;
  const $img = useRef<HTMLImageElement>(null);
  const [srcUrl, setSrcUrl] = useState<string | undefined>(
    lazy ? realDefaultSrc : realSrc
  );
  const handleImageError = () => {
    setSrcUrl(realDefaultSrc);
  };
  useEffect(() => {
    if ($img.current && lazy) {
      rootImageIntersectionObserver?.observe($img.current);
      return () => {
        // eslint-disable-next-line react-hooks/exhaustive-deps
        rootImageIntersectionObserver?.unobserve($img.current as any);
      };
    }
  }, [$img, lazy]);
  return (
    <img
      ref={$img}
      className={styles.lazyImage}
      data-src={lazy ? realSrc : null}
      src={srcUrl}
      style={style}
      onError={handleImageError}
      alt={alt}
    />
  );
};

export default Image;
```
